学习笔记



第二周学习心得



HashMap      二叉搜索树               堆             图



HashMap （O(1)）

本质上是一个数组 + 映射函数（Hash函数）

对每一个存储的值进行hash映射获得数组对应的下标，然后存入数组中

具体的实现有多种

主要在解决哈希冲突（碰撞）上，不同语言采用了不同的实现方式

Java采用了链表法，对于hash值相同的，放入同一个链表中，如果链表长度过长，就用红黑树来替换链表，加快搜索效率（logn）;

其他语言有采用开放寻址方法和二级hash映射；

开放寻址是向下寻找数组中空余的空间来存储，但增加了每次查询的难度和实现难度；

二级映射和多级映射，是进行多次hash,减小了碰撞效率，但增加了转换的难度。

实际上，哈希碰撞的概率是由hashMap的容量和hash函数的实现决定的，hash函数设计得好，哈希越分散，那么在相同的容量情况下，碰撞概率更低，查询的效率也就越高。

在JAVA的对象中，每一个类都有默认实现的hashCode方法，这返回的hashCode是由JDK自己实现的Hash函数映射后获得的值，根据这个值，我们可以对每一个对象的hashCode进行对比，不同的hashCode肯定不是同一个对象。





树（主要是二叉树和多叉树）

二叉搜索树也叫二叉树，根节点有两个子树，每个节点有一个或2个子节点，最后一列没有子节点。

应用：前序，中序，后序，层序遍历，可以用于加减乘除运算

用于红黑树时，左儿子小于根的值，右儿子大于根，遍历时，中序遍历可以获得从小到大排列的一组数

多叉树是根节点可以有超过2个子节点的树状图。





堆

堆排序是堆常用的使用，大顶堆和小顶堆，大顶堆每次取出已构建堆的最大值，小顶堆每次取出已构建堆的最小值。构建堆的时间复杂度是O(n),查找是O(logn); 

常见的是二叉堆，可以用数组或链表实现。

Java中的实现是PriorityQueue，优先队列，每次取出优先级最高的一项，传入Comparable的实现如a1 > a2,小顶堆；a2 > a1，大顶堆。



图

Edge 和Vertex是图的最重要两个属性



Vertex有两个属性

度（入度和出度）

联通性：是或否

Edge有两个属性

方向：有或者无

权重：边长

两种图:无向无权图，无向有权图，有向无权图，有向有权图。

两种表示

邻接矩阵  二维数组的实现

邻接表  数组+链表的实现





















